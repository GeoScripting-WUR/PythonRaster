---
author: "Jan Verbesselt, Jorge Mendes de Jesus, Aldo Bergsma, Dainius Masiliunas, David Swinkels"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  knitrBootstrap::bootstrap_document:
    title: "Week 3: Python for geo-scripting"
    theme: "simplex"
    highlight: Tomorrow Night Bright
    menu: FALSE
    theme.chooser: TRUE
    highlight.chooser: TRUE
---

# [WUR Geoscripting](https://geoscripting-wur.github.io/) ![WUR logo](https://www.wur.nl/upload/b43b7095-e452-482a-8969-fed9a50393a8_WUR_RGB_standard.png)

_Jan Verbesselt, Jorge Mendes de Jesus, Aldo Bergsma, Dainius Masiliunas, David Swinkels_ - `r format(Sys.time(), '%d %B, %Y')`

# Handling Raster data with Python

## Intro

Howdy. Good morning. Today we will be playing with Python packages for spatial raster analysis.
Python has some dedicated packages to handle rasters:

* [Rasterio](https://rasterio.readthedocs.io/en/latest/) focuses on raster analysis
* [PyProj](https://github.com/jswhit/pyproj) for re-projecting
* [NumPy](http://www.numpy.org/) is fundamental package for scientific computing, such as array calculations
* [matplotlib](https://matplotlib.org/) for plotting
* [GDAL](https://en.wikipedia.org/wiki/GDAL) is powerful library for reading, writing and warping raster datasets
* [PySAL](https://pysal.readthedocs.io/en/latest/) is library for spatial analysis functions
* [descartes](https://pypi.org/project/descartes/#description) is library to plot geometric objects as matplotlib paths and patches

```{r, engine = 'python', eval=FALSE}
conda create -n rasterpython python=3.6 pip
source activate rasterpython
pip install rasterio geopandas rasterstats matplotlib owslib pysal descartes

```

Before Rasterio there was one Python option for accessing the many different kind of raster data files used in the GIS field: the Python bindings distributed with the Geospatial Data Abstraction Library [GDAL]. These bindings extend Python, but provide little abstraction for GDAL’s C API. This means that Python programs using them tend to read and run like C programs. For example, GDAL’s Python bindings require users to watch out for dangling C pointers, potential crashers of programs. This is bad: among other considerations Rasterio chose Python instead of C to avoid problems with pointers. Rasterio strives to use modern Python language features and idioms. Rasterio is about high performance, lower cognitive load, cleaner and more transparent code ([source](https://rasterio.readthedocs.io/en/latest/intro.html)).

## Reading raster data with OWSLib and Rasterio

Raster data can be read from a file or from a Web Coverage Service. A Web Coverage Service can load raster data in a similar way as Web Feature Service can load vector data. Web Coverage Services are a standard by the Open Geospatial Consortium ([source](https://www.opengeospatial.org/standards/wcs)) and allow the downloading of raster data with multiple types of format encoding: GeoTIFF, netCDF, JPEG2000 etc. A [Web Map Service](https://www.opengeospatial.org/standards/wms) also allows downloading of images but without the data. Web Map Services serve the map images as visualizations. 

Today we will work with some height rasters. Have a look at the Web Coverage Service of the AHN. The AHN stands for "Actueel Hoogtebestand Nederland" and is a raster dataset that contains the height pixels of the whole of The Netherlands.

```{r, engine = 'python', eval=FALSE}
from owslib.wcs import WebCoverageService
wcs = WebCoverageService('http://geodata.nationaalgeoregister.nl/ahn2/wcs?service=WCS', version='1.0.0')
print(list(wcs.contents))
```

The Web Coverage Service of the AHN2 has four contents: 0.5m interpolated, 0.5m not interpolated, 0.5m rough and 5m. The meters identify the pixel size. 

```{r, engine = 'python', eval=FALSE}
print([op.name for op in wcs.operations])
```

The Web Coverage Service can be accessed for it's data (GetCoverage), metadata (DescribeCoverage) or capabilities (GetCapabilities).

```{r, engine = 'python', eval=FALSE}
cvg = wcs.contents['ahn2_05m_ruw']
print(cvg.boundingBoxWGS84)
print(cvg.supportedCRS)
print(cvg.supportedFormats)
```

The metadata of each content is accessible. Supported formats for AHN are GeoTIFF with different data types. 

Let's have a look at the data. We don't want to overload the web service. So when we download and directly store the data, we can use the data multiple times without having to call the web service again. Download the Digital Surface Model [DSM] and Digital Terrain Model [DTM] rasters of WUR Campus and store the rasters to local files.

```{r, engine = 'python', eval=FALSE}
x, y = 174100, 444100
bbox = (x-500, y-500, x+500, y+500)
response = wcs.getCoverage(identifier='ahn2_05m_ruw', bbox=bbox, format='GEOTIFF_FLOAT32',
                           crs='urn:ogc:def:crs:EPSG::28992', resx=0.5, resy=0.5)
with open('./AHN2_05m_DSM.geotiff', 'wb') as file:
    file.write(response.read())

response = wcs.getCoverage(identifier='ahn2_05m_int', bbox=bbox, format='GEOTIFF_FLOAT32',
                           crs='urn:ogc:def:crs:EPSG::28992', resx=0.5, resy=0.5)
with open('./AHN2_05m_DTM.geotiff', 'wb') as file:
    file.write(response.read())
```

Reading the raster data with Rasterio is very straightforward.

```{r, engine = 'python', eval=FALSE}
import rasterio
DSM = rasterio.open("./AHN2_05m_DSM.geotiff", driver="GTiff")
DTM = rasterio.open("./AHN2_05m_DTM.geotiff", driver="GTiff")
print(DSM.meta)
print(DTM.meta)
```

The metadata shows us everything we need to know about the raster data. It shows the driver, datatype, nodata value, width of raster in cells, height of raster in cells, coordinate system and transformation values. This is very valuable information. We can notice that both of the rasterio objects only have one raster layer. The raster layers can be read from the rasterio object with the method `.read()`. 

```{r, engine = 'python', eval=FALSE}
print(type(DSM))
print(type(DSM.read(1)))

print(DSM.read(1))
```

On the backend of rasterio the rasters are stored as numpy arrays. This makes it easy to perform array calculations. Hmm an array does show a lot of numbers, but is not a user friendly way to visualize your data. Let's make a geographical visualization of the DSM and DTM with Matplotlib. Matplotlib allows numpy arrays to be passed to the plot and can give you a nice plot with a legend.

```{r, engine = 'python', eval=FALSE}
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(10,10))
dsmplot = ax.imshow(DSM.read(1), cmap='Oranges', extent=bbox)
ax.set_title("Digital Surface Model - WUR Campus", fontsize=14)
cbar = fig.colorbar(dsmplot)
cbar.ax.get_yaxis().labelpad = 15
cbar.ax.set_ylabel('Height (m)', rotation=270)
ax.set_axis_off()
plt.show()

fig, ax = plt.subplots(figsize=(10,10))
dtmplot = ax.imshow(DTM.read(1), cmap='Oranges', extent=bbox)
ax.set_title("Digital Terrain Model - WUR Campus", fontsize=14)
cbar = fig.colorbar(dtmplot)
cbar.ax.get_yaxis().labelpad = 15
cbar.ax.set_ylabel('Height (m)', rotation=270)
ax.set_axis_off()
plt.show()
```


If you don't like the orange colormap of matplotlib, it is possible to change to [another colormap](https://matplotlib.org/examples/color/colormaps_reference.html).

## Calculating raster data

Often rasters need to be combined to get to the information you need. A Canopy Height Model [CHM] can be created by subtracting a Digital Terrain Model from a Digital Surface Model. Rasterio relies on NumPy to perform array calcuations. Numpy arrays can be subtracted, added or indexed with multiple raster layers.

```{r, engine = 'python', eval=FALSE}
CHM = DSM.read() - DTM.read()
print(type(CHM))
```

To store the numpy array, rasterio needs to combine metadata and the raster data. It is possible to use the metadata of the DSM or DTM that you had before, but the metadata can also be created from scratch. #To do: Explain affine transformation.

```{r, engine = 'python', eval=FALSE}
import affine
kwargs = {'driver': 'GTiff',
          'dtype': 'float32',
          'nodata': None,
          'width': 2000,
          'height': 2000,
          'count': 1,
          'crs': rasterio.crs.CRS({'init': 'epsg:28992'}),
          'transform': affine.Affine(0.5, 0.0, 173600.0, 0.0, -0.5, 444600.0)}
# Optional: kwargs = DSM.meta
with rasterio.open('./AHN2_05m_CHM.geotiff', 'w', **kwargs) as file:
    file.write(CHM.astype(rasterio.float32))
```

Now if we load the file and print the metadata, it exactly shows what type of data we are working with.
```{r, engine = 'python', eval=FALSE}
CHM = rasterio.open("./AHN2_05m_CHM.geotiff")
print(CHM.meta)
```

Let's make a plot to compare the three height rasters. Another way to plot your figure is directly with Rasterio. On the backend the plot of Rasterio makes uses of matplotlib and numpy to make hte plots.  

```{r, engine = 'python', eval=FALSE}
from rasterio.plot import show
fig, (axr, axg, axb) = plt.subplots(1, 3, figsize=(21, 7))
show(DSM, ax=axr, title='DSM')
show(DTM, ax=axg, title='DTM')
show(CHM, ax=axb, title='CHM')
plt.show()
```


## Processing satellite images

The data set for the raster python session can be downloaded from:
https://www.dropbox.com/s/rsc4lzkd3t2adq5/ospy_data5.zip?dl=0

Landsat 8 data is available from [Dropbox](https://www.dropbox.com/s/zb7nrla6fqi1mq4/LC81980242014260-SC20150123044700.tar.gz?dl=0).


```{r, engine = 'python', eval=FALSE}
# import modules
from osgeo import gdal
from osgeo.gdalconst import GA_ReadOnly, GDT_Float32
import numpy as np

# open file and print info about the file
# the ¨../¨ refers to the parent directory of my working directory
filename = 'data/ospy_data5/aster.img'
dataSource = gdal.Open(filename, GA_ReadOnly)

print "\nInformation about " + filename 
print "Driver: ", dataSource.GetDriver().ShortName,"/", \
      dataSource.GetDriver().LongName

```

# Assignment

For this scripting challenge I have downloaded a Landsat image with all bands process to surface reflectance (Level 1T). You can download it from [here](https://www.dropbox.com/s/zb7nrla6fqi1mq4/LC81980242014260-SC20150123044700.tar.gz?dl=0). Unzip the file and you will see that it contains all the invidual bands. 

Now, write a well-structured and documented script where you define a function to derive the NDWI and derive it from the landsat image and reproject the image to Lat/Long WGS84 (`x.ImportFromEPSG(4326)`).

`NDWI = band 4 - band 5 / band 4 + band 5` ([more info about](http://nsidc.org/data/docs/daac/nsidc0332_smex03_srs_ndvi_ndwi_ok.gd.html) `NDWI`)

A clean and well structured script is critical here.

## Deadline

Upload your documented and well structured Python script to a GitLab repository.

## Landsat data

You can easily order landsat data via:

  * https://earthexplorer.usgs.gov/
  
Once the have the Landsat ID you can order further processed data (e.g. resampled, or as geotif, etc.) via:

  * http://espa.cr.usgs.gov/index/
